# CSAPP

《深入理解计算机系统 第三版》 Computer Systems A Programmer's Perspective Third Edition

## 目录

1. [序](#序)
1. [第1章 计算机系统漫游](#第1章-计算机系统漫游)

## 序

1. 问题抽象、系统抽象和数据抽象是计算机类专业毕业生的核心能力，而本书担负起了系统抽象的重任。

## 第1章 计算机系统漫游

1. 信息就是位+上下文
    1. 源程序是由0和1组成的位（又称比特）序列
    1. 8个位为1字节
    1. 只由 ASCII 字符构成的文件称为文本文件，所有其他文件都称为二进制文件
    1. 系统中所有的信息都是由一串比特表示的，区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文
1. 程序被其他程序翻译成不同的格式
    1. hello.c（源程序 文本文件）-> 预处理器（cpp）-> hello.i （修改了的源程序 文本文件） -> 编译器（ccl） -> hello.s（汇编程序 文本文件） -> 汇编器（as） -> hello.o （可重定位目标程序 二进制文件） and printf.o -> 链接器（ld） -> hello （可执行目标文件 二进制文件）
    1. 预处理阶段
        1. 将 #include 指令的内容插入到程序文本中等处理操作
    1. 编译阶段
        1. 将源程序翻译成汇编程序
    1. 汇编阶段
        1. 将汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序 (relocatable object program)
    1. 链接阶段
        1. 链接不同的目标文件，得到可执行目标文件（简称可执行文件），可以被加载到内存中，由系统执行
1. 了解编译系统如何工作是大有益处的
1. 处理器读并解释存储在内存中的指令
1. 高速缓存至关重要
    1. 局部性原理，程序具有访问局部区域里的数据和代码的趋势
        1. 空间局部性、时间局部性
    1. L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的
    1. 意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级
1. 存储设备形成层次结构
1. 操作系统管理硬件
    1. 操作系统有两个基本功能
        1. 防止硬件被失控的应用程序滥用
        1. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备
    1. 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能
        1. 文件是对 I/O 设备的抽象表示
        1. 虚拟内存是对主存和磁盘 I/O 设备的抽象表示
        1. 进程是对处理器、主存和 I/O 设备的抽象表示
    1. 进程
        1. 对于一个程序，操作系统会提供一种假象，好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备
            1. 处理器就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象
            1. 这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一
        1. 进程是操作系统对一个正在运行的程序的一种抽象
            1. 传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能执行多个程序
            1. 无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的
            1. 操作系统实现这种交错执行的机制称为**上下文切换**
        1. 操作系统保持跟踪进程运行所需的所有状态信息，也就是上下文。包括 PC 和寄存器文件的当前值，以及主存的内容等信息
            1. 当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程
        1. 从一个进程到另一个进程的转换是由操作系统**内核**（kernel）管理的
            1. 内核是操作系统代码常驻主存的部分
            1. 当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的**系统调用**（system call）指令，将控制权传递给内核
            1. 内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合
        1. 实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作
    1. 线程
        1. 在现代系统中，一个进程可以由多个称为**线程**的执行单元组成
        1. 每个线程都运行在进程的上下文中，并共享同样的代码和全局数据
    1. 虚拟内存
        1. 虚拟内存时一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存
        1. 每个进程看到的内存都是一致的，称为**虚拟地址空间**
        1. 每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能，以下区从最低的地址开始，逐步向上
            1. 程序代码和数据
                1. 对所有进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置
                1. 代码和数据区在进程一开始运行时就被指定了大小
            1. 堆
                1. 调用 C 标准库的 malloc 和 free 等函数，堆可以在运行时动态地扩展和收缩
            1. 共享库
                1. 存放像 C 标准库和数学库这样的共享库的代码和数据的区域
            1. 栈
                1. 位于用户虚拟地址空间顶部，编译器用它来实现函数调用
                1. 和堆一样，用户栈在程序执行期间可以动态扩展和收缩
                1. 每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩
            1. 内核虚拟内存
                1. 地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数
                1. 应用程序必须调用内核来执行这些操作
        1. 虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译
        1. 基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存
    1. 文件
        1. 文件就是字节序列，仅此而已
        1. 每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件
        1. 系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的
        1. 文件这个概念向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O 设备
1. 系统之间利用网络通信
    1. 从一个单独的系统来看，网络可视为一个 I/O 设备
    1. 系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器
    1. 系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存
1. 重要主题
    1. 系统是硬件和系统软件相互交织的集合体，它们必须共同协作以达到运行应用程序的最终目的
    1. Amdahl 定律
        1. 当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度
        1. 要想显著加速整个系统，必须提升全系统中相当大的部分的速度
        1. 如果 60% 的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有 2.5
        1. 性能提升 2 倍或更高的比例因子只有通过优化系统的大部分组件才能获得
    1. 并发和并行
        1. 并发（concurrency）是一个通用的概念，指一个同时具有多个活动的系统
        1. 并行（parallelism）指的是用并发来使一个系统运行得更快
        1. 线程级并发
            1. 单处理器
                1. 通过进程间快速切换模拟并发执行
            1. 多处理器
                1. 多核
                    1. 将多个 CPU（称为核） 集成到一个集成电路芯片上
                    1. 每个核都有自己的 L1 和 L2 高速缓存
                    1. 其中 L1 高速缓存分为 L1 指令高速缓存，保存最近取到的指令；还有 L1 指令高速缓存，存放数据
                    1. 这些核共享更高层次的高速缓存（如 L3 高速缓存)，以及到主存的接口
                1. 超线程（hyperthreading）
                    1. 也称为同时多线程（simultaneous multi-threading)
                    1. 是一项允许一个 CPU 执行多个控制流的技术
                    1. 常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程
                    1. 多核和超线程的出现极大地激发了找到利用硬件开发线程级并行性应用程序的方法的愿望
        1. 指令级并行
            1. 在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为**指令级并行**
            1. 处理器使用了流水线（pipelining）等非常多的聪明的技巧来同时处理多条指令
            1. 如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为**超标量**（superscalar）处理器
        1. 单指令、多数据并行
            1. 在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作
            1. 这种方式称为**单指令、多数据**，即 SIMD（Single Instruction, Multiple Data） 并行
            1. 使用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型
            1. Modern CPUs have advanced SIMD operation support such as AVX2, AVX3 which provide SIMD (instructions) acceleration
    1. 计算机系统中抽象的重要性
        1. **抽象**的使用是计算机科学中最为重要的概念之一
        1. 在处理器里，**指令集架构**提供了对实际处理器硬件的抽象
        1. **虚拟机**提供对整个计算机的抽象，包括操作系统、处理器和程序

## 第2章 信息的表示和处理

1. 前言
    1. 二值信号能够容易地被表示、存储和传输，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场
    1. 无符号（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字
    1. 补码（two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字
    1. 浮点数（floating-point）编码是表示实数的科学记数法的以2为基数的版本
    1. 由于表示的精度有限，浮点运算是不可结合的。例如 表达式 (3.14+1e20)-1e20 求得的值会是0.0，而 3.14+(1e20-1e20) 求得的值会是3.14
    1. 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的
1. 信息存储
    1. 大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位
    1. 机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）
    1. 内存的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为**虚拟地址空间**（virtual address space）
    1. 这个虚拟地址空间只是一个展现给机器级程序的概念性映像，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组
    1. 十六进制表示法
        1. 十六进制 （hexadecimal）
        1. 用十六进制书写，一个字节的值域为 00~FF
    1. 字数据大小
        1. 每台计算机都有一个**字长**（word size），指明指针数据的标称大小（nominal size）
        1. 因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小
        1. 对于一个字长 ω 位的机器而言，虚拟地址的范围为 0~2的ω次方-1，程序最多访问2的ω次方个字节
        1. 大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容
        1. 在编译时提供不同的参数可以指定程序可以运行在 32 位机器上，64 位机器上，或两者都可运行
        1. 因此，我们将程序称为 “32位程序” 或 “64位程序” 时，区别在于该程序是如何编译的，而不是其运行的机器类型
        1. ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化，比如，int32_t 和 int64_t 分别为4个字节和8个字节
        1. 使用确定大小的整数类型是程序员准确控制数据表示的最佳途径
    1. 寻址和字节顺序
        1. 对于跨越多字节的程序对象，必须建立两个规则：
            1. 这个对象的地址是什么
            1. 在内存中如何排列这些字节
        1. 几乎所有机器上，多字节对象被存储为连续的字节序列，对象的地址为所使用字节中最小的地址
        1. 排列表示一个对象的字节有两个通用的规则
            1. 某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象
            1. 而另一些机器则按照从最高有效字节到最低有效字节的顺序存储
            1. 前一种规则——最低有效字节在最前面的方式，称为**小端法**（little endian）
            1. 后一种规则——最高有效字节在最前面的方式，称为**大端法**（big endian）
            1. 假设变量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567，地址范围 0x100~0x103 的字节顺序依赖于机器的类型：
                1. 大端法：
                    1. 0x100    0x101   0x102   0x103
                    1. 01       23      45      67
                1. 小端法：
                    1. 0x100    0x101   0x102   0x103
                    1. 67       45      23      01
        1. 大多数 Intel 兼容机都只用小端模式
        1. 许多比较新的微处理器是**双端法**（bi-endian），也就是收可以把它们配置成作为大端或者小端的机器运行
            1. 然而，实际情况是，一旦选择了特定操作系统，那么字节顺序也就固定下来
            1. 比如 ARM 微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统 Android 和 iOS 却只能运行于小端模式
        1. 对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的，无论为哪种类型的机器所编译的程序都会得到同样的结果
        1. 不过有时候字节顺序会成为问题
            1. 首先是在不同类型的机器之间通过网络传送二进制数据时，比如小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的
            1. 为了避免这问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示
            1. 第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要，这通常发生在检查机器级程序时
            1. 第三种情况是当编写规避正常的类型系统的程序时
                1. 在C语言中，可以通过使用强制类型转换（cast）或联合（union）来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同
    1. 表示字符串
        1. 在使用 ASCII 码作为字符码的任何系统上输出字符数组的字节表示都将得到相同的结果，与字节顺序和字大小规则无关
        1. 因而，文本数据比二进制数据具有更强的平台独立性
    1. 表示代码
        1. 不同机器编译的程序会生成不同的机器代码，不同的机器类型使用不同的且不兼容的指令和编码方式
        1. 二进制代码很少能在不同机器和操作系统组合之间移植
        1. 从机器的角度来看，程序仅仅只是字节序列，机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外
    1. 布尔代数简介
    1. C语言中的位级运算
        1. [inplace-swap.c](inplace-swap.c)
        1. [reverse-array.c](reverse-array.c)
        1. 掩码运算
            1. 0x89ABCDEF & 0xFF = 0x000000EF
            1. ~0 = 全1的掩码 不同字长的机器位数不同
    1. C语言中的逻辑运算
        1. 逻辑运算符
            1. ||
            1. &&
            1. !
            1. 断路：如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值
        1. 常见的编程错误是在想用逻辑运算的时候用了位级运算，或者反过来
    1. C语言中的移位运算
        1. 左移：丢弃最高位，右端补0
        1. 逻辑右移：左端补0
        1. 算术右移：左端补最高有效位
        1. C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移
        1. 然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移。对于无符号数，右移必须是逻辑的
        1. Java对于如何进行右移有明确的定义，表达式 x>>k 是算术右移，而 x>>>k 是逻辑右移
1. 整数表示
